import { PatternSettings, PatternData } from "../pattern-data/interfaces";
import { ExtendedRegExp } from "../extended-regexp/extended_regexp";
import { TemplateSpecification, SpecificationData } from "../template-spec/template_specification";
declare class Pattern {
    settings: PatternSettings;
    vars: PatternData;
    placeholders: PatternData;
    /** Starts construction of a new pattern. */
    static new(): PatternBuilder;
}
declare abstract class PatternBuilderBase {
    readonly pattern: Pattern;
    /** Builds the template into an extended regex object using the pattern's settings. */
    build(spec?: new (...args: any[]) => TemplateSpecification): ExtendedRegExp;
    /** Builds the templates into a list of extended regex objects using the pattern's settings. */
    buildAll(spec?: new (...args: any[]) => TemplateSpecification): ExtendedRegExp[];
    protected assembleData(): SpecificationData;
    protected pickSpecification(data: SpecificationData, spec?: new (...args: any[]) => TemplateSpecification): TemplateSpecification;
    protected addTemplateVariable(target: string, data: string[] | string, input: string): void;
    private setKey;
    private changeTemplate;
}
declare class PatternSettingsBuilder extends PatternBuilderBase {
    /**
     * Defines the settings for a pattern. This has to contain at minimum the template string used to build it.
     * Optionally, one can specify regex flags, a custom character used for array joins (default `|`), or a custom symbol
     * to indicate template variables with (default none).
     *
     * Examples:
     *
     *      .settings({ template: 'foo(bar)'});
     *
     *      .settings({ template: 'foobar', flags: 'g'});
     *
     *      .settings({ template: '#foo #bar', symbol: '#'});
     *
     *      .settings({
     *        template: ['foo(bar)','(bar)foo'],
     *        separator: '|'
     *       });
     */
    settings(settings: PatternSettings): this;
    /** Adds a template string to build the pattern from. Use this method for faster building when you're not using any other settings. */
    template(template: string | string[]): this;
}
declare class PatternDataBuilder extends PatternBuilderBase {
    /**
     * @deprecated
     * Defines the data for a pattern. Any name in the template string will be replaced with the contents
     * of the equivalent name provided in this data.
     * Deprecated: use `vars()` instead.
     */
    data(data: PatternData): this;
    /**
     * Defines the template variables for this pattern. Any name in the template string will be replaced with the values
     * of the key provided here. String arrays will be joined with a `|` or with a custom separator if specified in the settings.
     *
     * Placeholders can be defined with `{{myPlaceholder}}` and their values can be added with `placeholder()`.
     *
     * Examples:
     *
     *       .vars({ foo: 'bar' })
     *
     *       .vars({ foo: ['bar','baz'] })
     *
     *       .vars({ foo: '{{bar}}' })
     *
     *       .vars({ foo: 'bar', moo: ['{{baz}}','bal'] })
     */
    vars(vars: PatternData): this;
}
declare class PatternPlaceholderBuilder extends PatternBuilderBase {
    /**
     * Defines the data used to substitute placeholder syntax in the template `{{myPlaceholder}}`.
     * For example, if you add a placeholder `{{foo}}` to the data, add a key `foo` to this data with the values to replace it with.
     *
     *       .placeholders({ foo: 'bar' })
     *
     *       .placeholders({ foo: ['bar', 'baz'] })
     */
    placeholders(placeholders: PatternData): this;
}
declare class PatternFilterBuilder extends PatternBuilderBase {
    /**
     * @experimental
     * Defines one or more values to except for a regex search. Note this will change existing template structure
     * to `exclude|(the_rest_of_the_template)`. Exceptions _will be matched but placed in index 0 of the matches array only_.
     * Desired matches will be placed in capturing group 1 instead.
     */
    filter(exceptions: string | string[]): this;
    /** Alias for `filter()`. */
    except(exceptions: string | string[]): this;
}
declare class PatternWildCardBuilder extends PatternBuilderBase {
    /**
     * @experimental
     * Defines a wildcard match to be used after searching for known values. Note this will change existing template structure to
     * `the_rest_of_the_template|(wildcard)`, adding a capturing group but not changing the order of ones already present.
     */
    wildcard(wildcard: string | string[]): this;
}
declare class PatternBuilder {
    readonly pattern: Pattern;
}
interface PatternBuilder extends PatternBuilderBase, PatternSettingsBuilder, PatternDataBuilder, PatternPlaceholderBuilder, PatternFilterBuilder, PatternWildCardBuilder {
}
export { Pattern, PatternBuilder, PatternBuilderBase };
