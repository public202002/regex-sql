import { TemplateBracketHandler } from "../template-group-handler/template_string_handler.js";
/** Decorated JavaScript RegExp with additional methods and properties. */
export class ExtendedRegExp {
    constructor(pattern, template, automap) {
        this.pattern = pattern;
        this.template = template;
        this.automap = automap;
    }
    get dotAll() {
        return this.pattern.dotAll;
    }
    get flags() {
        return this.pattern.flags;
    }
    /** @experimental Node v16 feature */
    get hasIndices() {
        // @ts-ignore
        return this.pattern.hasIndices;
    }
    get global() {
        return this.pattern.global;
    }
    get ignoreCase() {
        return this.pattern.ignoreCase;
    }
    get lastIndex() {
        return this.pattern.lastIndex;
    }
    set lastIndex(value) {
        this.pattern.lastIndex = value;
    }
    get multiline() {
        return this.pattern.multiline;
    }
    get source() {
        return this.pattern.source;
    }
    get sticky() {
        return this.pattern.sticky;
    }
    get unicode() {
        return this.pattern.unicode;
    }
    /** Throughput method for RegExp.exec. */
    exec(string) {
        return this.pattern.exec(string);
    }
    /** Throughput method for RegExp.test. */
    test(string) {
        return this.pattern.test(string);
    }
    /** Throughput method for String.match.  */
    match(string) {
        if (this.automap) {
            return this.matchMap(string);
        }
        return string.match(this.pattern);
    }
    /** Throughput method for String.matchAll. */
    matchAll(string) {
        return string.matchAll(this.pattern);
    }
    /** Throughput method for String.replace. */
    replace(string, replaceValue) {
        return string.replace(this.pattern, replaceValue);
    }
    /** Throughput method for String.search. */
    search(string) {
        return string.search(this.pattern);
    }
    /** Throughput method for String.split. */
    split(string, limit) {
        return string.split(this.pattern, limit);
    }
    // -----Additional methods-----
    /** Returns the template string for this pattern. */
    getTemplate() {
        return this.template;
    }
    /**
     * @experimental
     * Performs String.match(RegExp) but maps the matches to an object with the
     * pattern's template capturing groups as keys.
     *
     * For example, when given RegExpMatchArray
     * `['hello world', 'world']` with template `'greeting (region)'`,
     *  the result will be
     *  `{ full_match: 'hello world', region: 'world' }`.
     */
    matchMap(string) {
        const matches = string.match(this.pattern);
        if (!matches)
            return null;
        return this.map(matches);
    }
    /**
     * @experimental
     * Maps an array of matches according to the template of the pattern.
     * Returns an object with a key for the full match and one for each capturing group in the template.
     * Called as part of `matchMap()`.
     */
    map(matches) {
        const map = { full_match: matches[0] };
        const groupNames = new TemplateBracketHandler(this.template, '(').handleBrackets();
        if (/\bfilter\b/.test(this.template)) {
            throw new Error(`(regexbuilder) Error mapping template: Cannot map unnamed capturing group added with "filter" method. Please use
             the indexes of the matches array instead when using a filter (valid matches in index 1, exceptions only in index 0).`);
        }
        for (const [i, name] of groupNames.entries()) {
            map[name] = matches[i + 1];
        }
        return map;
    }
}
