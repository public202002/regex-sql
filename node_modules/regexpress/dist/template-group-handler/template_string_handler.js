import { hasDuplicates } from "../utils/duplicates.js";
class TemplateStringHandler {
    constructor(template, openingBracket) {
        this.template = template;
        this.openingBracket = openingBracket;
        this.brackets = [];
        this.templateUnits = [];
        this.outerUnit = [];
        this.tier = 0;
    }
    closingBracketType() {
        if (this.openingBracket === '(')
            return ')';
        else if (this.openingBracket === '[')
            return ']';
        else if (this.openingBracket === '{')
            return '}';
        else
            return '>';
    }
    extractTemplateGroups(index = 0) {
        let template = (typeof this.template === 'string') ? this.template : this.template[index];
        for (let i = 0; i < template.length; i++) {
            if (template[i] === this.openingBracket) {
                this.brackets.push({ bracket: template[i], index: i });
            }
            else if (template[i] === this.closingBracketType()) {
                const lastOpener = this.brackets[this.brackets.length - 1];
                const nestedUnit = template.slice(lastOpener.index, i + 1);
                template = this.removeNestedUnit(nestedUnit, template);
                i -= nestedUnit.length;
                this.brackets.pop();
                this.finishOuterUnit();
            }
        }
    }
    // outer units L -> R
    // nested (inner) unit R -> L
    removeNestedUnit(nestedUnit, template) {
        if (this.noTierChange()) {
            this.outerUnit.push(nestedUnit);
        }
        else {
            this.outerUnit.unshift(nestedUnit);
            this.tier = this.brackets.length;
        }
        return template.replace(nestedUnit, '');
    }
    noTierChange() {
        return (this.tier === this.brackets.length);
    }
    finishOuterUnit() {
        if (this.brackets.length === 0) {
            this.templateUnits = this.templateUnits.concat(this.outerUnit);
            this.outerUnit = [];
        }
    }
}
class TemplateBracketHandler extends TemplateStringHandler {
    /**
     * Keeps track of opening and closing parentheses to extract nested regex groups one at a time,
     * from the innermost tiers to the outermost tiers. Filters out non-capturing groups and template
     * variable symbols to return a list of groups that can be mapped directly with matches found
     * using the template's pattern.
     */
    handleBrackets() {
        this.extractTemplateGroups();
        this.templateUnits = this.clean();
        return this.templateUnits;
    }
    clean() {
        if (hasDuplicates(this.templateUnits)) {
            throw new Error('(regexbuilder) Error: Cannot map duplicate template variables.');
        }
        return this.templateUnits
            .filter(e => {
            return !/\?[:<=!]?/.test(e);
        })
            .map((e, i, arr) => {
            return arr[i] = e.replace(/\(|\)|[!@#%]/g, '');
        })
            .filter(e => {
            return !/^\\/.test(e);
        });
    }
}
export { TemplateBracketHandler };
