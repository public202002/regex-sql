import { stringOrRegExp } from "../utils/string_or_regexp.js";
import { RegexBuilderBase } from "./regex_builder_base.js";
import { groupStarters, processGroupCode } from "./process_group_code.js";
export class RegexNestBuilder extends RegexBuilderBase {
    /** Starts the addition of a nested tier to the regex. */
    nest() {
        this.changeNestState(1, groupStarters.cg);
        return this;
    }
    /** Finishes a nested tier in the regex. An integer can be passed to complete multiple tiers at once or an asterisk to finish all remaining nests. */
    unnest(n) {
        if (!n || n === 0) {
            this.changeNestState(-1, groupStarters.close);
            return this;
        }
        if (n === '*') {
            this.changeNestState(-this.nests, groupStarters.close);
            return this;
        }
        this.changeNestState(-n, groupStarters.close);
        return this;
    }
    /** Combines methods `nest()` and `add()`. */
    nestAdd(part, type = 'cg') {
        const grouptype = processGroupCode(type);
        this.changeNestState(1, grouptype);
        this.regex.parts.push(stringOrRegExp(part));
        return this;
    }
    /** Combines methods `nest()` and `noncapture()`. */
    nestNonCapture() {
        this.changeNestState(1, groupStarters.ncg);
        return this;
    }
    /** Combines methods `nest()` and `lookahead()`. */
    nestLookahead() {
        this.changeNestState(1, groupStarters.la);
        return this;
    }
    /** Combines methods `nest()` and `lookbehind()`. */
    nestLookbehind() {
        this.changeNestState(1, groupStarters.lb);
        return this;
    }
    /** Combines methods `nest()` and `negatedLA()`. */
    nestNegatedLA() {
        this.changeNestState(1, groupStarters.nla);
        return this;
    }
    /** Combines methods `nest()` and `negatedLB ()`. */
    nestNegatedLB() {
        this.changeNestState(1, groupStarters.nlb);
        return this;
    }
    /** Combines methods `nest()` and `namedGroup()`. */
    nestNamed(name, content) {
        this.changeNestState(1, `(?<${name}>${stringOrRegExp(content)}`);
        return this;
    }
    changeNestState(num, char) {
        for (let i = 0; i < Math.abs(num); i++) {
            this.regex.parts.push(char);
        }
        this.nests += num;
    }
}
